### ThreadLocal
- 해당 쓰레드만 접근할 수 있는 저장소 (`java.lang.ThreadLocal`)
- 테스트 : `ThreadLocalService.java`, `ThreadLocalServiceTest.java`
- `ThreadLocal<T>`를 사용한다.
- **주의사항** : 사용 후 `remove()`를 통해 제거하지 않았을 경우, 새로운 요청이 기존 요청의 ThreadLocal 값을 읽는 위험한 일이 발생할 수 있다.

### 템플릿 메서드 패턴
- ![템플릿 메서드 패턴](./images/image001.png)
- 다형성을 활용하여 **변하는 것**과 **변하지 않는 것**을 분리한다.
- 부모 클래스(Abstract Class)에 변하지 않는 템플릿을 두고, 변하는 부분(Abstract Method)을 자식 클래스에서 구현한다. 
- 테스트 : `TemplateMethodTest.java`
- 상속을 사용하기 때문에 클래스간 강하게 결합된다. (심지어 부모의 기능을 사용하지 않더라도)
- 어쨌든 원본 코드를 수정하긴 해야함

### 전략 패턴
- ![전략 패턴](./images/image002.png)
- 변하지 않는 부분을 `Context`에 두고, 변하는 부분을 `Strategy` 인터페이스로 구현하여 문제를 해결
- 상속이 아닌 위임
- 테스트 : `ContextV1Test.java`
- 파라미터로 `Strategy`를 건내면 유연한 의존성 주입이 가능하다.
- 어쨌든 원본 코드를 수정하긴 해야함

### 템플릿 콜백 패턴
- 다른 코드의 인수로서 넘겨주는 실행 가능한 코드를 콜백이라고 함
- 템플릿 코드가 존재하고, 템플릿에서 사용 할 콜백 메서드를 파라미터로 주입해 주는 패턴
- 위에서 개발한 전략 패턴과 유사
- 테스트 : `TemplateCallbackTest.java`
- 어쨌든 원본 코드를 수정하긴 해야함

### 프록시 패턴
- 프록시 객체로 변경해도 클라이언트 코드에 수정이 없어야 한다.
- 클라이언트는 서버에게 요청 한 것인지, 프록시에 요청한 것인지 몰라야 한다.
- 프록시의 주요 기능
  - 접근 제어 (프록시 패턴)
    - 권한에 따른 접근 차단
    - 캐싱
    - 지연 로딩
  - 부가 기능 추가 (데코레이터 패턴)
    - 원래 서버가 제공하는 기능에 더해서 부가 기능을 수행
- 테스트 : `ProxyPatternTest.java`, `CacheProxy.java`
- **인터페이스 프록시** : 변경할 가능성이 있다면 유리하지만, 인터페이스를 매번 만들기 번거롭다.
- **클래스 프록시** : 상속을 사용하기 때문에 제약이 많다.
- 어찌되었건, 위 두 방법은 모두 공통 관심사 로직을 위한 클래스나 인터페이스를 매번 만들어줘야 하는 불편함이 있다.

### 데코레이터 패턴
- 프록시 패턴과 비슷하지만, 주로 부가 기능 추가에 사용 됨
- 테스트 : `DecoratorPatternTest.java`

### 동적 프록시
#### 리플렉션
- 리플렉션 테스트 : `ReflectionTest.java`
- 리플렉션은 클래스나 메서드의 메타정보를 사용해서 동적으로 호출하는 메서드를 변경할 수 있다.
- 하지만 리플렉션은 런타임에 동작하기 때문에 컴파일 시점에 오류를 잡을 수 없다. (위험하다)

#### JDK 동적 프록시
- 테스트 : `JdkDynamicProxyTest.java`
- 동적 프록시를 통해 개발자가 직접 프록시 클래스를 만들지 않아도 된다.
- JDK 동적 프록시는 **인터페이스를 기반**으로 프록시를 동적으로 만들어준다.
- JDK 동적 프록시에 적용할 로직은 `InvocationHandler` 인터페이스를 구현해서 작성하면 된다.
  - 파라미터
    - `proxy` : 프록시 자신
    - `method` 호출한 메서드
    - `args` : 메서드를 호출할 때 전달한 인수
- `Proxy`는 `InvocationHandler` 구현 클래스의 로직을 실행한다.
  - 인터페이스에 대한 메소드 요청이 들어오면, Proxy가 그걸 받고, `InvocationHandler`의 `invoke`를 실행하고, 내부에 메서드의 수행이 있으면 수행한다.
- ![동적 프록시 순서](./images/image003.png)
- 한계
  - 인터페이스 대신 클래스만 사용하는 경우 -> `CGLOB`이라는 바이트코드 조작 라이브러리를 사용해야 한다.
#### `CGLIB`
  - 바이트코드를 조작해서 동적으로 클래스를 생성하는 기술을 제공한다.
  - **구체 클래스만으로** 동적 프록시를 만들 수 있다.
  - 스프링의 내부 소스 코드에 포함되어있다.(라이브러리를 추가하지 않아도 된다.)
  - JDK 동적 프록시의 `InvocationHandler`처럼, `CGLIB`은 `MethodInterceptor`를 제공한다.
  - 테스트 : `CglibTest.java`
  - `Enhancer`를 통해 프록시를 생성한다.
  - 프록시를 만들 때 상속 구조이다. (`final` 키워드에 민감하다.)
  - 클래스에 대한 메소드 요청이 들어오면, 클래스를 상속받은 Proxy가 그걸 받고, `MethodInterceptor`의 `intercept()`를 실행하고, 내부에 메서드의 수행이 있으면 수행한다.
  - ![CGLIB 프록시 순서](./images/image004.png)
