### 개요
- 데이터베이스마다 사용하는 방법이 모두 다르다.
  - 데이터베이스를 변경하려면 애플리케이션 서버의 코드도 함께 변경되어야 한다.
  - 개발자가 연결 방법을 새롭게 학습해야 한다.
- JDBC 표준 인터페이스 등장
  - `java.sql.Connection` : 연결
  - `java.sql.Statement` : SQL
  - `java.sql.ResultSet` : SQL 요청 응답
  - JDBC 인터페이스에 맞는 `JDBC 드라이버`를 각 벤더사에서 개발한다.
  - 애플리케이션 서버의 코드는 JDBC 표준 인터페이스에만 의존하면 된다.
  - 하지만 복잡하고, 각 DB에 맞는 SQL을 맞추기가 어렵다.
- `SQL Mapper`, `ORM` 등장
  - `SQL Mapper` : 스프링 JdbcTemplate, MyBatis
  - `ORM` : JPA, 하이버네이트, 이클립스링크
  - 내부적으로는 JDBC를 사용한다. -> 동작에 대해 알아야 한다.

### JDBC
![DriverManager 커넥션 요청 흐름](./images/image001.png)
- `DriverManager.getConnection()`을 호출하면, URL정보를 통해 처리할 수 있는 요청인지 확인한다. 그리고 커넥션을 획득해 반환한다.

### Connection-Pool
- DB 커넥션을 새로만드는건 복잡하고 시간이 많이 걸린다.
- 커넥션을 미리 만들어두고, 커넥션 풀에 저장하여 사용한다.
- 어플리케이션은 커넥션을 사용하고, 종료하지 않은채 반환한다.
- `commons-dbcp2`, `tomcat-jdbc pool`, `HikariCP` 등이 있다.
- DriveManager나, Connection Pool 모두 커넥션을 획득하는 방법이 다르므로, 자바는 `javax.sql.DataSource` 인터페이스를 제공한다.(추상화)
- 설정과 사용의 분리를 제공한다.

### Transaction
- 트랜잭션이 보장하는 `ACID`
  - 원자성 : 트랜잭션은 모두 성공하거나 모두 실패
  - 일관성 : 트랜잭션은 일관성 있는 데이터베이스 상태를 유지
  - 격리성 : 트랜잭션은 서로 영향을 미치지 않음
  - 지속성 : 트랜잭션을 성공적으로 끝내면 항상 그 결과가 기록
- 트랜잭션 격리 수준
  - `READ UNCOMMITED` : 커밋되지 안히은 읽기
  - `READ COMMITED` : 커밋된 읽기
  - `REPEATABLE READ` : 반복 가능한 읽기
  - `SERIALIZABLE` : 직렬화 가능
- 데이터베이스 연결 구조
  - 클라이언트는 데이터베이스와 커넥션을 맺는다.
  - 데이터베이스는 세션을 만들고, 이 커넥션을 통한 모든 요청은 해당 세션을 통해 실행한다.
  - 커넥션을 닫거나 세션을 강제로 종료하면 세션은 종료된다.
- 트랜잭션
  - 자동 커밋 : `set autocommit true;`
  - 수동 커밋 : `set autocommit false;`
- DB 락
  - 트랜잭션의 원자성을 보장한다.
  - 락을 가지고 있는 동안, 다른 트랜잭션에서 데이터 수정을 하지 못한다.
  - 일반적으로 조회느 락을 사용하지 않는다.
    - `for update`로 강제로 락을잡을 수 있다.
- 트랜잭션 위치
  - ![비즈니스 로직과 트랜잭션](./images/image002.png)
  - 트랜잭션은 비즈니스 로직이 있는 서비스 계층에서 시작해야 한다.(비즈니스 문제 시 롤백 필요)
  - 트랜잭션을 사용하는 동안 같은 커넥션을 유지해야 한다.
  - 서비스 계층은 중요한 비즈니스 로직을 담고 있으므로, 특정 기술에 종속적이지 않게 개발해야 한다.
  - 기술이 변경되더라도, 서비스 계층의 코드 변경은 발생하지 않도록 해야한다.
- `PlatformTransactionManager`
  - ![TransactionManager](./images/image003.png)
  - 스프링은 트랜잭션 추상화 기술을 제공한다.
- 트랜잭션 동기화 매니저
  - ![동기화 매니저](./images/image004.png)
  - 스프링은 트랜잭션 동기화 매니저를 제공한다.
    - `ThreadLocal`을 사용해 커넥션을 동기화한다.(멀티스레드에 안전)
  - "트랜잭션 매니저"는, "트랜잭션 동기화 매니저"에 커넥션을 보관한다.
  - 레포지 토리는 이 "트랜잭션 동기화 매니저"에서 커넥션을 꺼내 사용한다.
- 트랜잭션 AOP
  - ![프록시](./images/image005.png)
  - 트랜잭션은 중요한 기능이므로, 스프링은 트랜잭션 AOP를 처리하기 위한 기능을 제공한다.
  - 트랜잭션 처리가 필요한 곳에 `@Transactional`을 붙이면 된다.
    - 스프링 부트를 사용하면 자동으로 등록되지만, 어드바이저, 포인트컷, 어드바이스 빈을 필요로한다.
  - ![트랜잭션 AOP 전체 흐름](./images/image006.png)
  - 선언적 트랜잭션 관리 : `@Transactional`을 통한 트랜잭션 관리 (대부분의 경우 사용)
  - 프로그래밍 방식의 트랜잭션 관리 : 트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용한 트랜잭션 관리
- 스프링 부트 자동 리소스 등록
  - 데이터 소스
    - `application.properties`의 `spring.datasource.~~`
    - 스프링은 기본적으로 `HikariDataSource`를 제공
  - 트랜잭션 매니저
    - 현재 등록된 라이브러리를 보고 어떤 트랜잭션 매니저르 선택할지 판단
  - 직접 등록할 경우, 직접 등록한 설정이 우선적으로 사용된다.
